CREATE DATABASE shop;
-- из файлов к дз взял source04.zip, и из файла shop.sql импортировал таблицы в бд shop
USE shop;
-- ЗАДАНИЕ 1
-- Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.

UPDATE users SET
created_at = NOW(),
updated_at = NOW();

SELECT * FROM users;
/*
 * ЗАДАНИЕ 2
 * Таблица users была неудачно спроектирована. 
 * Записи created_at и updated_at были заданы типом VARCHAR и в них долгое время помещались значения в формате 20.10.2017 8:10.
 * Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.
*/
-- портим данные
ALTER TABLE users
MODIFY COLUMN created_at VARCHAR(128),
MODIFY COLUMN updated_at VARCHAR(128);

UPDATE users SET
created_at = DATE_FORMAT(created_at, '%d.%m.%Y %H:%i'),
updated_at = DATE_FORMAT(updated_at, '%d.%m.%Y %H:%i')

-- Перед тем как поменять тип поля необходимо изменить формат даты
UPDATE users SET
	created_at = STR_TO_DATE(created_at, '%d.%m.%Y %H:%i'),
	updated_at = STR_TO_DATE(updated_at, '%d.%m.%Y %H:%i');

-- Меняем тип поля
ALTER TABLE users
MODIFY COLUMN created_at DATETIME,
MODIFY COLUMN updated_at DATETIME;

/*
 * В таблице складских запасов storehouses_products в поле value могут встречаться самые разные цифры:
 * 0, если товар закончился и выше нуля, если на складе имеются запасы. Необходимо отсортировать записи таким образом, 
 * чтобы они выводились в порядке увеличения значения value. Однако нулевые запасы должны выводиться в конце, после всех 
 */
-- для начала надо наполнить данными
INSERT INTO `storehouses` VALUES (1,'velit','1991-04-29 09:22:30','2016-08-09 20:00:22'),(2,'reprehenderit','1983-10-09 10:28:49','2001-03-15 20:14:56'),(3,'omnis','2013-10-06 11:47:54','1974-05-07 02:15:05'),(4,'beatae','2016-04-05 21:55:27','1973-10-29 14:14:58'),(5,'voluptates','1980-01-09 10:05:05','2001-03-20 11:06:26'),(6,'quod','2005-11-25 19:08:21','1994-09-15 12:37:56'),(7,'consequuntur','2014-02-09 19:54:14','1972-07-04 21:16:30'),(8,'nulla','1971-01-18 22:12:17','2008-10-06 17:16:28'),(9,'sit','1977-12-18 18:34:31','1981-02-28 05:06:34'),(10,'tempore','2000-09-08 04:56:30','1971-11-30 16:51:32');
INSERT INTO `storehouses_products` VALUES (1,4,1,1,'1978-08-07 12:47:38','2010-07-29 16:33:35'),(2,8,7,9,'1987-12-11 11:01:39','1992-05-15 19:59:19'),(3,1,4,2,'1979-08-26 15:35:01','2008-08-02 09:48:08'),(4,5,7,7,'1978-04-14 23:03:58','1991-07-02 18:44:26'),(5,2,6,9,'1983-11-04 23:18:16','2017-08-25 13:54:50'),(6,4,3,7,'1997-04-17 09:56:19','2004-06-25 05:50:05'),(7,6,4,3,'1989-11-04 09:15:13','2006-03-18 03:58:18'),(8,8,4,1,'1975-10-29 10:57:55','2015-06-19 15:46:18'),(9,5,2,8,'1995-05-02 22:59:23','1974-06-01 05:43:05'),(10,8,4,4,'2002-01-17 04:16:21','2004-11-09 22:10:24'),(11,7,3,6,'2007-09-07 11:08:58','1989-09-16 14:57:33'),(12,4,5,0,'2016-03-16 06:54:46','1995-01-21 13:30:32'),(13,4,5,0,'1992-05-08 03:55:46','1998-01-24 15:54:46'),(14,9,3,9,'2011-01-07 21:46:48','2019-02-01 16:49:20'),(15,9,7,0,'1973-06-02 01:09:34','2007-01-05 10:55:31'),(16,2,2,3,'1991-06-30 06:49:49','2005-12-03 17:04:56'),(17,6,5,6,'2000-06-01 21:31:24','1971-06-02 02:59:28'),(18,8,3,5,'1976-09-28 23:02:46','2009-05-01 15:00:00'),(19,10,4,9,'2003-03-13 12:36:29','2007-09-21 11:38:22'),(20,4,7,7,'1986-02-23 14:59:51','1995-10-26 02:28:19'),(21,10,2,2,'2012-05-13 07:39:57','2017-10-30 04:25:26'),(22,2,2,6,'2004-01-13 10:29:56','2021-09-09 11:59:43'),(23,3,4,6,'1974-01-27 16:23:37','2003-10-12 09:47:55'),(24,5,2,8,'2010-09-08 05:06:46','2022-04-02 04:41:42'),(25,7,2,6,'1990-05-14 03:29:44','2000-03-11 00:31:48'),(26,7,2,6,'1997-10-19 13:08:02','1994-05-29 23:55:40'),(27,6,4,6,'1990-02-22 11:30:17','1989-06-19 02:13:15'),(28,5,2,9,'2020-10-09 04:08:38','1988-11-08 11:36:20'),(29,1,5,7,'2020-05-23 23:45:37','2008-09-02 11:03:22'),(30,9,5,7,'2013-11-07 10:05:08','2019-04-02 22:16:18');

-- SELECT * FROM storehouses_products ORDER BY CASE value WHEN 0 THEN 'a' ELSE value END;
SELECT * FROM storehouses_products ORDER BY CASE value WHEN 0 THEN ~0 ELSE value END;


/*
 * (по желанию) Из таблицы users необходимо извлечь пользователей, родившихся в августе и мае. 
 * Месяцы заданы в виде списка английских названий (may, august)
 */
SELECT id, name, birthday_at from users WHERE MONTH(birthday_at) in (5,8);
-- про месяцы в виде англ названий не совсем понял, поле ведь представляет из себя дату после действий выше
SELECT id, name, birthday_at, LOWER(MONTHNAME(DATE(birthday_at))) as birthday_month from users WHERE LOWER(MONTHNAME(DATE(birthday_at))) in ('august', 'may');

/*
 * (по желанию) Из таблицы catalogs извлекаются записи при помощи запроса. 
 * SELECT * FROM catalogs WHERE id IN (5, 1, 2);
 * Отсортируйте записи в порядке, заданном в списке IN.
 */

SELECT * FROM catalogs WHERE id IN (5, 1, 2) ORDER BY FIELD(id, 5,1,2) ;

-- Практическое задание теме «Агрегация данных»
/*
 * Подсчитайте средний возраст пользователей в таблице users.
 */
-- Вариант 1 
SELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday_at,CURDATE()))) as avg_age FROM users;
-- Вариант 2
-- SELECT YEAR(NOW())-YEAR(birthday_at), DATE_FORMAT(CURRENT_DATE, '%m%d') < DATE_FORMAT(birthday_at , '%m%d') FROM users
SELECT ROUND(AVG((YEAR(NOW())-YEAR(birthday_at) - (DATE_FORMAT(CURRENT_DATE, '%m%d') < DATE_FORMAT(birthday_at , '%m%d'))))) as avg_age FROM users;


/*
 * Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели.
 * Следует учесть, что необходимы дни недели текущего года, а не года рождения.
 */
-- SELECT CONCAT(YEAR(NOW()),'-', DATE_FORMAT(birthday_at, '%m-%d')) FROM users;
SELECT DAYNAME(CONCAT(YEAR(NOW()),'-', DATE_FORMAT(birthday_at, '%m-%d'))) as bd_weekday, COUNT(*) as cnt FROM users GROUP BY bd_weekday;

/*
 * (по желанию) Подсчитайте произведение чисел в столбце таблицы.
 */
SELECT id from users;
-- 1*2*3*4*5*6 = 720
SELECT EXP(SUM(LN(id))) from users;	
